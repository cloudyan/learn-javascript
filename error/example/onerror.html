<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>错误异常捕获 onerror vs addEventListener error</title>
  <script>
    // 获取堆栈信息
    function getStackMessage(stack) {
      if (!stack) return '';
      return stack
        .split('\n')
        .slice(1)
        .map((item) => item.replace(/^\s+at\s+/g, ''))
        .join('^');
    }
    // 错误格式
    function formatError(event = {}, uncaughtType) {
      const {
        message = '',
        filename = '',
        lineno = 0,
        colno = 0,
        error,
      } = event;
      const stack = getStackMessage(error?.stack);
      const data = {
        uncaught_type: uncaughtType,
        type: 'SyntaxError', // errorType
        sub_type: 'uncaught',
        filename,
        message,
        stack,
        position: `${lineno}:${colno}`,
        selector: '',
      };
      console.warn(JSON.stringify(data, null, 2));
      return data;
    }
    (function() {
      const handleError = window.onerror
      window.onerror = function(message, filename, lineno, colno, error) {
        var msg = message.toLowerCase();
        var subMsg = "script error";
        if (msg.indexOf(subMsg) > -1) {
          console.warn('Script Error: See Browser Console for Detail');
        } else {
          // console.warn('onerror:err', arguments);
          // console.warn('onerror:source', filename);
          // console.warn('onerror:source', source);
          // console.warn('onerror:lineno', lineno);
          // console.warn('onerror:colno', colno);
          // console.warn('onerror:error', error);
          // console.warn('onerror:error.stack', error.stack);
          formatError({
            message,
            filename,
            lineno,
            colno,
            error,
          }, 'onerror');
        }

        handleError && handleError(arguments)

        // 若该函数返回 true，则阻止执行默认事件处理函数（输出错误信息到 console）
        // 注: 红皮书上此处 说返回 false，是错误的描述，直接可验证得到结论(相比较 MDN 站点更准确)
        // return true;
      }

      // 跨域的JS资源，window.onerror拿不到详细的信息，需要往资源的请求添加额外的头部。
      // 静态资源请求需要加多一个Access-Control-Allow-Origin头部，同时script引入外链的标签需要加多一个crossorigin的属性。
    })();

    // 错误监听
    window.addEventListener('error', (event) => {
      // 只处理 window 事件
      // if (event.target !== window) return

      // ErrorEvent 类型的event包含有关事件和错误的所有信息。
      // 也可以捕获到错误，但这个拿到的 JS 报错堆栈往往是不完整的(待验证)
      console.warn('addEventListener');
      console.warn('error:err', event);
      // console.warn('error:message', message);
      // console.warn('error:filename', filename);
      // console.warn('error:lineno', lineno);
      // console.warn('error:colno', colno);
      // console.warn('error:error', error);
      // console.warn('error:error.stack', stack);

      formatError(event, 'error');

      // 禁止默认错误提示
      // event.preventDefault();
    }, true);

  </script>
</head>
<body>
  <!-- 资源错误 -->
  <!-- <img src="../404.png" /> -->
  <script>
    // 模拟错误

  </script>
  <!-- <script src="./js/syntax-error.js"></script> -->
  <!-- <script src="./js/async-error.js"></script> -->
  <script src="./js/sync-error.js"></script>
</body>
</html>
