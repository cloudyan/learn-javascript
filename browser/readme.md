# 浏览器架构

- [浏览器架构](#浏览器架构)
  - [基础知识](#基础知识)
    - [并发和并行](#并发和并行)
    - [进程与线程](#进程与线程)
    - [进程和线程之间的关系有以下特点](#进程和线程之间的关系有以下特点)
    - [协程的原理](#协程的原理)
  - [浏览器的多进程架构](#浏览器的多进程架构)
    - [结构](#结构)
    - [多线程的浏览器内核](#多线程的浏览器内核)
  - [参考](#参考)

## 基础知识

### 并发和并行

- 并发：分别有任务 A 和 任务 B，在一段时间内通过任务之间的切换来完成这两个任务，这个情况是并发。
- 并行：还是任务 A 和任务 B，但是 CPU 存在两个核心，可以同时执行这两个任务，这种情况是并行。

### 进程与线程

- 进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
  - 一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。
- 线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位）
  - 线程是依附于进程存在，而进程中使用多线程并行处理能提升运算效率。
- 协程，英文 Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。
  - 因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。

tips:

1. 不同进程之间也可以通信，不过代价较大
2. 单线程与多线程，都是指在一个进程内的单和多

### 进程和线程之间的关系有以下特点

- 一个进程可以包含有多个线程；
- 线程之间可以共享进程中的数据；
- 进程之间的内容相互隔离，不同进程数据不能共享；
- 进程中的任意一线程执行出错，都会导致整个进程的崩溃；
- 当一个进程关闭之后，操作系统会回收进程所占用的内存。

区别

- 进程
  - 进程是操作系统分配资源的最小单位
  - 程序运行的实例
  - 同一个程序可以产生多个进程
  - 一个进程由一个或多个线程组成
  - 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见
- 线程
  - 线程是程序执行(操作系统能够进行运算调度)的最小单位
  - 线程一次只能执行一个任务
  - 有自己的调用栈、寄存器环境
  - 同一进程的线程共享进程资源
  - 调度和切换：线程上下文切换比进程上下文切换要快得多

一个进程还可以要求操作系统生成另一个进程来执行不同的任务，系统会为新的进程分配独立的内存，两个进程之间可以通过 IPC 机制（Inter Process Communication）来进行通信。很多应用都会采用这样的设计，如果一个工作进程反应迟钝，重启这个进程不会影响应用其它进程的工作。

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
- 并发性：任何进程都可以同其他进程一起并发执行；
- 独立性：进程是系统进行资源分配和调度的一个独立单位；
- 结构性：进程由程序、数据和进程控制块三部分组成。

协程的特点

- 线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。
- 线程的默认 Stack 大小是 1M，而协程更轻量，接近 1K。因此可以在相同的内存中开启更多的协程。
- 由于在同一个线程上，因此可以避免竞争关系而使用锁。
- 适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。

### 协程的原理

当出现 IO 阻塞的时候，由协程的调度器进行调度，通过将数据流立刻 yield 掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为 coroutine，而跑在由 coroutine 负责调度的线程称为 Fiber。比如 Golang 里的 go 关键字其实就是负责开启一个 Fiber，让 func 逻辑跑在上面。

由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。

因此，协程的开销远远小于线程的开销，也就没有了 ContextSwitch 上的开销。

参考：

- [一文读懂什么是进程、线程、协程](https://www.cnblogs.com/Survivalist/p/11527949.html)

## 浏览器的多进程架构

Chrome 浏览器采用多进程架构，其顶层存在一个浏览器主进程（Browser process）用以协调浏览器的其它进程。

最新的 Chrome 浏览器包括：

- 1 个浏览器主进程（Browser Process）
- 1 个 GPU 进程（GPU Process）
- 1 个网络进程（NetWork Process）
- 多个渲染进程（Renderer Process）
- 多个插件进程（Plugin Process）

详细

- **浏览器主进程**：主要负责页面显示、用户交互、子进程管理、文件存储等功能。
- **渲染进程**：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。
  - 排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。
  - 出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程**：负责处理 GPU 相关的任务。
  - 网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，使得 GPU 成为浏览器普遍的需求，最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- **网络进程**：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，之后独立处理成为一个单独的进程。
- **插件进程**：主要负责控制一个网页用到的所有插件。
  - 因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

### 结构

- 浏览器
  - 浏览器主进程
  - 插件进程
  - GPU 进程
  - 网络进程
  - 渲染进程（浏览器内核）
    - GUI 线程
    - JS 引擎线程
    - 事件触发线程
    - 定时触发器线程
    - 异步 http 请求线程

### 多线程的浏览器内核

浏览器的内核，是极其复杂的，毕竟浏览器的整个核心，就是它，它主要由以下五种线程组成：

1. GUI 渲染线程

   负责渲染浏览器界面（解析 HTML ，CSS，构建 DOM 树 CSSOM 树 和 Render 树 ，布局和绘制等）。

   GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行，当界面需要重绘或由于某种操作引发的重排时，该线程就会执行。

   **GUI 渲染线程与 JS 引擎线程是互斥的**，这也是造成 JS 堵塞 的原因所在。

   由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 引擎线程和 GUI 渲染线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

   因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。

   如果想了解有关于 CSS 和 JS 的堵塞问题，可以查阅 [面试中常问到的 CSS 堵塞和 JS 堵塞](https://juejin.cn/post/7044360789708242980)

2. JS 引擎线程

   也称为 JS 内核，负责处理 JavaScript 脚本程序。

   JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页中无论什么时候都只有一个 JS 线程在运行 JS 程序（我们早在之前说过了，JS 是一门单线程的语言。至于原因可以查阅 [单线程的 JS](https://juejin.cn/post/6886602875225833480#heading-1)

   再次注意，**GUI 渲染线程与 JS 引擎线程是互斥的** ，所以，如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3. 事件触发线程

   首先这属于浏览器而不是 JS 引擎，主要用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）

   当 JS 引擎执行代码块如 `setTimeOut` 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中。

   当对应的事件符合触发条件被触发时，该线程会把是事件添加到待处理队列（宏任务）的队尾，等待 JS 引擎的处理。

   同样地，由于 JS 是单线程的，所以需要等到 JS 引擎空闲了之后，才会对待处理队列进行处理。

4. 定时触发器线程

   传说中的 `setInterval` 与 `setTimeout` 所在线程。

   因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。

   因此通过单独线程来计时并触发定时，计时完毕后，添加到事件队列（宏任务）中，等待 JS 引擎空闲后执行。

   不禁感叹，懂得 JS 的单线程 原来那么有用。

   需要值得注意的是，W3C 在 HTML 标准中规定，规定要求 `setTimeout` 中低于 4ms 的时间间隔算为 4ms。

5. 异步 http 请求线程

   `XMLHttpRequest` 在连接后是通过浏览器新开的一个线程请求。

   当检测到状态更新时，如果没有设置回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列（微任务）中，等待 JS 引擎执行。

   关于这个事件队列的执行机制，以及对于 微任务 与 宏任务 云里雾里的，可以查阅[一文搞懂 JS 系列（六）之微任务与宏任务，Event Loop](https://juejin.cn/post/6886602875225833480)

   浏览器采用多进程的架构模型，通过进程之间的协作来实现网络请求、页面渲染、JavaScript 执行和 Web 安全防范等功能，并且 **提升了浏览器的稳定性、流畅性和安全性**。

- **稳定性**：进程之间相互隔离，某一个进程出现问题不会影响到其他进程。
  - 例如插件是比较容易出现问题的模块，如果是运行在同一个进程里面，插件的意外崩溃会引起整个浏览器的崩溃。
- **流畅性**：网络请求、页面渲染、JavaScript 执行环境和插件等运行在不同的进程里面，减少了线程阻塞的可能性。
  - 例如 JavaScript 是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。
- **安全性**：浏览器在系统层面上限定了不同进程的权限。
  - 例如渲染进程是运行在安全沙箱里面的，因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。

不过凡事都有两面性，虽然浏览器的多进程模型提升了浏览器的稳定性、流畅性和安全性，但是也带来了一些其它的问题：例如 **更高的资源占用和更复杂的体系结构**。

## 参考

- [[前端进阶] - 搞懂浏览器进程和线程](https://juejin.cn/post/7053974933931556900)
- [浏览器知识点整理（五）多进程架构](https://juejin.cn/post/6974796760489132069)
